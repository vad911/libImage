1. –ü—É–±–ª–∏—á–Ω–æ–µ API –±–∏–±–ª–∏–æ—Ç–µ–∫–∏

–ü—É–±–ª–∏—á–Ω—ã–º API —Å—á–∏—Ç–∞–µ–º –≤—Å—ë, —á—Ç–æ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ include/ –∏ –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω–æ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤–Ω–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏.

–°—Ç—Ä—É–∫—Ç—É—Ä–∞ public API
include/
‚îú‚îÄ Channel.h          ‚Üê –æ–ø–∏—Å–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–æ–≤
‚îú‚îÄ PixelFormat.h      ‚Üê –æ–ø–∏—Å–∞–Ω–∏–µ —Ñ–æ—Ä–º–∞—Ç–∞ –ø–∏–∫—Å–µ–ª—è
‚îú‚îÄ ImageCommon.h      ‚Üê –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
‚îú‚îÄ ImageContext.h     ‚Üê –≥–ª–æ–±–∞–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç (thread pool)
‚îú‚îÄ PixelConverter.h   ‚Üê —Ü–≤–µ—Ç–æ–≤—ã–µ –∫–æ–Ω–≤–µ—Ä—Å–∏–∏

üß© 2. API + –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ + –ø—Ä–∏–º–µ—Ä—ã
üü¶ Channel.h
using byte = uint8_t

–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ
–ï–¥–∏–Ω—ã–π –∞–ª–∏–∞—Å –¥–ª—è –±–∞–π—Ç–∞ –≤–æ –≤—Å–µ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–µ.

–ü—Ä–∏–º–µ—Ä

mylibImageReader::byte value = 255;

enum class ChannelType
enum class ChannelType : byte
{
    UInt8,
    UInt16,
    UInt32,
    Float32,
    Float64
};


–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ
–û–ø–∏—Å—ã–≤–∞–µ—Ç —Ç–∏–ø —Ö—Ä–∞–Ω–µ–Ω–∏—è –æ–¥–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞ (–Ω–µ –ø–∏–∫—Å–µ–ª—è!).

–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è:

PixelFormat

–≤–∞–ª–∏–¥–∞—Ü–∏—è

–≤—ã–±–æ—Ä SIMD / scalar path

–ü—Ä–∏–º–µ—Ä

ChannelType t = ChannelType::Float32;

enum class ChannelSemantic
enum class ChannelSemantic
{
    R, G, B, A,
    Y, Cb, Cr,
    Gray,
    H, S, V,
    X, Y_XYZ, Z,
    L, a, b,
    C, h,
    Unknown
};


–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ
–û—Ç–≤–µ—á–∞–µ—Ç –ß–¢–û –æ–∑–Ω–∞—á–∞–µ—Ç –∫–∞–Ω–∞–ª, –∞ –Ω–µ –∫–∞–∫ –æ–Ω —Ö—Ä–∞–Ω–∏—Ç—Å—è.

–≠—Ç–æ –∫–ª—é—á–µ–≤–∞—è –∏–¥–µ—è –¥–∏–∑–∞–π–Ω–∞:

Pixel = –Ω–∞–±–æ—Ä –∫–∞–Ω–∞–ª–æ–≤ —Å —Å–µ–º–∞–Ω—Ç–∏–∫–æ–π

–ü—Ä–∏–º–µ—Ä

ChannelSemantic s = ChannelSemantic::R;

struct ChannelDesc
struct ChannelDesc
{
    ChannelSemantic semantic;
    ChannelType     type;
    byte            bits;
};


–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ
–ü–æ–ª–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –æ–¥–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞.

–ü—Ä–∏–º–µ—Ä

ChannelDesc red {
    ChannelSemantic::R,
    ChannelType::UInt8,
    8
};

üü¶ PixelFormat.h
class PixelFormat

–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ
–û–ø–∏—Å—ã–≤–∞–µ—Ç —Ñ–æ—Ä–º–∞—Ç –æ–¥–Ω–æ–≥–æ –ø–∏–∫—Å–µ–ª—è:

—Å–∫–æ–ª—å–∫–æ –∫–∞–Ω–∞–ª–æ–≤

–∫–∞–∫–∏–µ –∫–∞–Ω–∞–ª—ã

–ø–æ—Ä—è–¥–æ–∫

—Ä–∞–∑–º–µ—Ä –ø–∏–∫—Å–µ–ª—è

–≠—Ç–æ –∫–ª—é—á–µ–≤–æ–π —Ç–∏–ø, –∫–æ—Ç–æ—Ä—ã–π –∑–∞–º–µ–Ω—è–µ—Ç vector<byte>.

PixelFormat(std::vector<ChannelDesc>)

–°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞.

–ü—Ä–∏–º–µ—Ä

PixelFormat rgb({
    {ChannelSemantic::R, ChannelType::UInt8, 8},
    {ChannelSemantic::G, ChannelType::UInt8, 8},
    {ChannelSemantic::B, ChannelType::UInt8, 8}
});

static PixelFormat RGB8()

–ì–æ—Ç–æ–≤—ã–π canonical —Ñ–æ—Ä–º–∞—Ç RGB.

–ü—Ä–∏–º–µ—Ä

PixelFormat fmt = PixelFormat::RGB8();

static PixelFormat RGBA8()

RGB + –∞–ª—å—Ñ–∞ (–Ω–µ premultiplied).

–ü—Ä–∏–º–µ—Ä

PixelFormat fmt = PixelFormat::RGBA8();

static PixelFormat Gray8()

–û–¥–Ω–æ–∫–∞–Ω–∞–ª—å–Ω—ã–π grayscale.

–ü—Ä–∏–º–µ—Ä

PixelFormat gray = PixelFormat::Gray8();

size_t pixelSizeBytes()

–†–∞–∑–º–µ—Ä –æ–¥–Ω–æ–≥–æ –ø–∏–∫—Å–µ–ª—è –≤ –±–∞–π—Ç–∞—Ö.

–ü—Ä–∏–º–µ—Ä

size_t bpp = fmt.pixelSizeBytes(); // 3 –¥–ª—è RGB8

bool hasAlpha()

–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –∞–ª—å—Ñ–∞-–∫–∞–Ω–∞–ª–∞.

–ü—Ä–∏–º–µ—Ä

if (fmt.hasAlpha()) {
    // —É—á–∏—Ç—ã–≤–∞—Ç—å –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å
}

üü¶ ImageCommon.h
class ImageCommon

–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ
–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:

—à–∏—Ä–∏–Ω–∞ / –≤—ã—Å–æ—Ç–∞

PixelFormat

—Å—ã—Ä–æ–π –±—É—Ñ–µ—Ä

stride

–≠—Ç–æ –∑–∞–º–µ–Ω–∞ —Å—Ç–∞—Ä–æ–≥–æ std::vector<byte>.

ImageCommon(int w, int h, PixelFormat fmt)

–°–æ–∑–¥–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è.

–ü—Ä–∏–º–µ—Ä

ImageCommon img(1920, 1080, PixelFormat::RGB8());

int width() / height()

–ü—Ä–∏–º–µ—Ä

int w = img.width();
int h = img.height();

byte* data()

–î–æ—Å—Ç—É–ø –∫ —Å—ã—Ä—ã–º –¥–∞–Ω–Ω—ã–º.

–ü—Ä–∏–º–µ—Ä

std::memset(img.data(), 0, img.stride() * img.height());

byte* rowPtr(int y)

–ö–ª—é—á–µ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è hot-loop.

–ü—Ä–∏–º–µ—Ä (–∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è)

for (int y = 0; y < img.height(); ++y)
{
    uint8_t* row = img.rowPtr(y);
    for (int x = 0; x < img.width(); ++x)
    {
        row[3*x+0] = 255;
        row[3*x+1] = 0;
        row[3*x+2] = 0;
    }
}

üü¶ ImageContext.h
class ImageContext

–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ
–ì–ª–æ–±–∞–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –±–∏–±–ª–∏–æ—Ç–µ–∫–∏:

–æ–¥–∏–Ω ThreadPool

—É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ—Ç–æ–∫–∞–º–∏

future: LUT, gamma, caps

ImageContext::instance()

Singleton.

–ü—Ä–∏–º–µ—Ä

auto& ctx = ImageContext::instance();

ThreadPool& threadPool()

–î–æ—Å—Ç—É–ø –∫ thread pool.

–ü—Ä–∏–º–µ—Ä

ctx.threadPool().parallelFor(0, h, 32, [&](int y0, int y1) {
    // –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Å—Ç—Ä–æ–∫
});

üü¶ PixelConverter.h
enum class ColorSpace
enum class ColorSpace
{
    RGB,
    RGBA,
    Gray,
    YCbCr,
    XYZ,
    Lab,
    LCh
};


–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ
–õ–æ–≥–∏—á–µ—Å–∫–æ–µ —Ü–≤–µ—Ç–æ–≤–æ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è.

PixelConverter::convert(...)
static void convert(
    const ImageCommon& src,
    ImageCommon& dst,
    ColorSpace dstSpace
);


–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ
–ì–ª–∞–≤–Ω–∞—è —Ç–æ—á–∫–∞ –≤—Ö–æ–¥–∞ –¥–ª—è —Ü–≤–µ—Ç–æ–≤—ã—Ö –∫–æ–Ω–≤–µ—Ä—Å–∏–π.

–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏:

–≤–∫–ª—é—á–∞–µ—Ç SIMD

–≤–∫–ª—é—á–∞–µ—Ç multithreading

–≤—ã–±–∏—Ä–∞–µ—Ç fast/slow path

–ü—Ä–∏–º–µ—Ä: RGB ‚Üí YCbCr
ImageCommon rgb(640, 480, PixelFormat::RGB8());
ImageCommon ycbcr(640, 480, PixelFormat::RGB8()); // 3 –∫–∞–Ω–∞–ª–∞

PixelConverter::convert(rgb, ycbcr, ColorSpace::YCbCr);

–ü—Ä–∏–º–µ—Ä: RGB ‚Üí Lab
ImageCommon lab(
    640, 480,
    PixelFormat({
        {ChannelSemantic::L, ChannelType::Float32, 32},
        {ChannelSemantic::a, ChannelType::Float32, 32},
        {ChannelSemantic::b, ChannelType::Float32, 32}
    })
);

PixelConverter::convert(rgb, lab, ColorSpace::Lab);

–ü—Ä–∏–º–µ—Ä: RGB ‚Üí LCh
ImageCommon lch(
    640, 480,
    PixelFormat({
        {ChannelSemantic::L, ChannelType::Float32, 32},
        {ChannelSemantic::C, ChannelType::Float32, 32},
        {ChannelSemantic::h, ChannelType::Float32, 32}
    })
);

PixelConverter::convert(rgb, lch, ColorSpace::LCh);

‚úÖ –ò—Ç–æ–≥

–¢—ã —Å–µ–π—á–∞—Å –∏–º–µ–µ—à—å:

‚úî –ß—ë—Ç–∫–∏–π public API
‚úî –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã–µ / —Ñ–æ—Ä–º–∞—Ç / –∫–æ–Ω–≤–µ—Ä—Å–∏—è
‚úî SIMD + threads —Å–∫—Ä—ã—Ç—ã –≤–Ω—É—Ç—Ä–∏
‚úî –£–¥–æ–±—Å—Ç–≤–æ –¥–ª—è decoder‚Äô–æ–≤ (JPEG/BMP/WebP)
‚úî –ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å —Å—Ç–∞—Ç—å core image conversion library

// --


–ß—Ç–æ —Ç–∞–∫–æ–µ Zero-copy DMA (PBO)

PBO (Pixel Buffer Object) ‚Äî —ç—Ç–æ –±—É—Ñ–µ—Ä –≤ OpenGL, –∫–æ—Ç–æ—Ä—ã–π:

–Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ GPU-–¥–æ—Å—Ç—É–ø–Ω–æ–π –ø–∞–º—è—Ç–∏

–º–æ–∂–µ—Ç –±—ã—Ç—å –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –∑–∞–ø–æ–ª–Ω–µ–Ω CPU

–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è OpenGL –±–µ–∑ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–∏ glTex(Sub)Image2D

üëâ –í –∏–¥–µ–∞–ª–µ:

CPU –ø–∏—à–µ—Ç ‚Üí GPU DMA —á–∏—Ç–∞–µ—Ç ‚Üí texture

–ë–µ–∑:

–ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã—Ö CPU-–∫–æ–ø–∏–π

–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ glTexImage2D

stall pipeline

üì¶ –ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∞—è —Å—Ö–µ–º–∞ (–ë–ï–ó PBO)
CPU buffer (ImageCommon)
   ‚Üì memcpy
driver staging buffer
   ‚Üì DMA
GPU texture


‚ùå 2 –∫–æ–ø–∏–∏
‚ùå CPU stall
‚ùå –ø–ª–æ—Ö–æ –¥–ª—è –≤–∏–¥–µ–æ / –±–æ–ª—å—à–∏—Ö —Ç–µ–∫—Å—Ç—É—Ä

üöÄ –°—Ö–µ–º–∞ —Å PBO (Zero-copy)
PBO (mapped)
  ‚Üë CPU writes
  ‚Üì DMA
GPU texture


‚úî –æ–¥–Ω–∞ –∫–æ–ø–∏—è
‚úî async
‚úî –∏–¥–µ–∞–ª—å–Ω–æ –¥–ª—è —Å—Ç—Ä–∏–º–∏–Ω–≥–∞

üß© –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π pipeline —Å ImageCommon
üîπ –í–∞—Ä–∏–∞–Ω—Ç A ‚Äî ImageCommon –≤–ª–∞–¥–µ–µ—Ç PBO (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
ImageCommon
 ‚îú‚îÄ CPU buffer
 ‚îî‚îÄ optional PBO


–∏–ª–∏

üîπ –í–∞—Ä–∏–∞–Ω—Ç B ‚Äî UploadContext (–ª—É—á—à–µ)
ImageCommon ‚Üí UploadContext ‚Üí OpenGL


–ú—ã –ø–æ–π–¥—ë–º –≤–∞—Ä–∏–∞–Ω—Ç B.

1Ô∏è‚É£ –°–æ–∑–¥–∞–Ω–∏–µ PBO
GLuint pbo = 0;
glGenBuffers(1, &pbo);
glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pbo);

size_t size = img.stride() * img.height();

glBufferData(
    GL_PIXEL_UNPACK_BUFFER,
    size,
    nullptr,               // no initial data
    GL_STREAM_DRAW
);


‚úî –ø–∞–º—è—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∞
‚úî –¥–∞–Ω–Ω—ã–µ –µ—â—ë –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã

2Ô∏è‚É£ Map PBO ‚Üí –ø–æ–ª—É—á–∏—Ç—å pointer
glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pbo);

uint8_t* pboPtr = (uint8_t*)glMapBufferRange(
    GL_PIXEL_UNPACK_BUFFER,
    0,
    size,
    GL_MAP_WRITE_BIT |
    GL_MAP_INVALIDATE_BUFFER_BIT |
    GL_MAP_UNSYNCHRONIZED_BIT
);


üí° –í–∞–∂–Ω–æ

INVALIDATE ‚Äî –¥—Ä–∞–π–≤–µ—Ä –º–æ–∂–µ—Ç –≤—ã–¥–∞—Ç—å –Ω–æ–≤—É—é –ø–∞–º—è—Ç—å

UNSYNCHRONIZED ‚Äî –±–µ–∑ –æ–∂–∏–¥–∞–Ω–∏—è GPU

3Ô∏è‚É£ Decoder / Converter –ø–∏—à–µ—Ç –Ω–∞–ø—Ä—è–º—É—é –≤ PBO
üî• –ö–õ–Æ–ß–ï–í–û–ï –ú–ï–°–¢–û
auto& pool = ImageContext::instance().threadPool();

pool.parallelFor(0, h, 32,
    [&](int y0, int y1)
{
    for (int y = y0; y < y1; ++y)
    {
        uint8_t* dst = pboPtr + y * img.stride();
        const uint8_t* src = decoder.rowPtr(y);

        // –ø—Ä–∏–º–µ—Ä: RGB ‚Üí RGBA –ø—Ä—è–º–æ –≤ PBO
        convertRowRGBtoRGBA(src, dst, w);
    }
});


‚ùó ImageCommon –º–æ–∂–Ω–æ –ù–ï —Å–æ–∑–¥–∞–≤–∞—Ç—å
‚ùó decoder ‚Üí SIMD convert ‚Üí PBO –Ω–∞–ø—Ä—è–º—É—é

–≠—Ç–æ –∏ –µ—Å—Ç—å –Ω–∞—Å—Ç–æ—è—â–∏–π zero-copy path.

4Ô∏è‚É£ Unmap + upload
glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);

glBindTexture(GL_TEXTURE_2D, tex);

glTexSubImage2D(
    GL_TEXTURE_2D,
    0,
    0, 0,
    w, h,
    GL_RGBA,
    GL_UNSIGNED_BYTE,
    nullptr   // ‚ö†Ô∏è –¥–∞–Ω–Ω—ã–µ –±–µ—Ä—É—Ç—Å—è –∏–∑ PBO
);


üí• nullptr ‚Äî —ç—Ç–æ –Ω–µ –æ—à–∏–±–∫–∞
üëâ OpenGL —á–∏—Ç–∞–µ—Ç –∏–∑ PBO, –Ω–µ –∏–∑ CPU

5Ô∏è‚É£ –î–≤–æ–π–Ω–∞—è –±—É—Ñ–µ—Ä–∏–∑–∞—Ü–∏—è (—Ä–µ–∞–ª—å–Ω–æ –≤–∞–∂–Ω–æ)

–ß—Ç–æ–±—ã CPU –∏ GPU –Ω–µ –∂–¥–∞–ª–∏ –¥—Ä—É–≥ –¥—Ä—É–≥–∞:

GLuint pbos[2];
int frame = 0;

GLuint pbo = pbos[frame & 1];
frame++;

Frame	CPU –ø–∏—à–µ—Ç	GPU —á–∏—Ç–∞–µ—Ç
0	PBO0	‚Äî
1	PBO1	PBO0
2	PBO0	PBO1
üß† –ì–¥–µ —ç—Ç–æ –¥–∞—ë—Ç –º–∞–∫—Å–∏–º—É–º –ø–æ–ª—å–∑—ã

‚úî –í–∏–¥–µ–æ (30‚Äì240 FPS)
‚úî –ö–∞–º–µ—Ä—ã
‚úî Streaming textures
‚úî Scientific visualization

‚ö†Ô∏è –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è
–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ	–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π
Driver	–ù–µ–∫–æ—Ç–æ—Ä—ã–µ –¥—Ä–∞–π–≤–µ—Ä—ã –≤—Å—ë —Ä–∞–≤–Ω–æ –∫–æ–ø–∏—Ä—É—é—Ç
iGPU	–ú–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–Ω—å—à–µ –≤—ã–∏–≥—Ä—ã—à
Small images	overhead > benefit
üß† –°–≤—è–∑—å —Å —Ç–≤–æ–µ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π
üîπ PixelConverter —É–º–µ–µ—Ç:
convert(
    const ImageCommon& src,
    byte* dst,
    PixelFormat dstFmt
);


üëâ dst = pboPtr

üîπ UploadContext (–∏–¥–µ—è API)
UploadContext ctx;
ctx.beginPBO(w, h, PixelFormat::RGBA8());

byte* ptr = ctx.map();
PixelConverter::convert(src, ptr, PixelFormat::RGBA8());
ctx.unmapAndUpload(tex);

üß† –ü–æ—á–µ–º—É —ç—Ç–æ –Ω–µ ¬´–ª–∏—à–Ω–µ–µ¬ª

–¢—ã –ø–æ–ª—É—á–∞–µ—à—å:

‚úî zero-copy
‚úî async upload
‚úî –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π latency
‚úî –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ—Å—Ç—å

–î–∞–∂–µ –µ—Å–ª–∏ —Å–µ–π—á–∞—Å –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—à—å ‚Äî –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ —É–∂–µ –≥–æ—Ç–æ–≤–∞.